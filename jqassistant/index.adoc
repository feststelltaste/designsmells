:toc: left
= Identifying Design Smells with jQAssistant

This document shows possible solutions for the design smell analysis challenge.

// tag::default[]
[[default]]
[role=group,includesConcepts="designsmell:*"]
// end::default[]

== Design Smells


=== Abstraction

==== God
// tag::designsmellGod[]
[[designsmell:God]]
[source,cypher,role=concept]
.A class or interface with very many methods.
----
MATCH (t:Type)-[:DECLARES]->(m:Method)
RETURN t.fqn, COUNT(m) as Methods
ORDER BY Methods DESC
LIMIT 1
----
// end::designsmellGod[]

==== Passive Abstraction (Data class)
// tag::designsmellPassiveAbstraction[]
[[designsmell:PassiveAbstraction]]
[source,cypher,role=concept]
.A class declares fields without any methods operating on it.
----
MATCH
  (field:Field)<-[:DECLARES]-(class:Class)-[:DECLARES]->(method:Method)
WHERE NOT
  (method)-[:READS|:WRITES]->(field)
RETURN
  class AS Class, field AS Field, method AS `used by`
LIMIT 4
----
// end::designsmellPassiveAbstraction[]

// tag::designsmellPassiveAbstractionExample[]
[[designsmell:PassiveAbstractionExample]]
[source,cypher,role=concept,reportType="plantuml-class-diagram"]
.Example: query result produces class diagram
----
MATCH
  (field:Field)<-[:DECLARES]-(class:Class {name: "DataHolder"})-[:DECLARES]->(method:Method)
WHERE NOT
  (method)-[:READS|:WRITES]->(field)
RETURN
  *
----
// end::designsmellPassiveAbstractionExample[]

==== Unutilized Abstraction (Hidden class)
// tag::designsmellUnutilizedAbstraction[]
[[designsmell:UnutilizedAbstraction]]
[source,cypher,role=concept]
.A class/interface that is not being used by anyone.
----
MATCH
  (obsoleteType:Type)
WHERE NOT
  (obsoleteType)<-[:DEPENDS_ON]-(:Type)
RETURN
  obsoleteType.fqn
LIMIT 4
----
// end::designsmellUnutilizedAbstraction[]

// tag::designsmellUnutilizedAbstractionExample[]
[[designsmell:UnutilizedAbstractionExample]]
[source,cypher,role=concept]
.Example: query shows overall usage of concrete classes.
----
MATCH
  (consumer:Class)-[:DEPENDS_ON*]->(class:Class)
RETURN
  class.fqn AS Class, COUNT(consumer) AS `used by other classes`
ORDER BY
  `used by other classes` DESC
LIMIT 4
----
// end::designsmellUnutilizedAbstractionExample[]

==== Sibling
// tag::designsmellSibling[]
[[designsmell:Sibling]]
[source,cypher,role=concept]
.Classes or interfaces with the same name in different packages.
----
MATCH
  (c1:Type),(c2:Type)
WHERE c1.name = c2.name AND c1 <> c2
RETURN
  c1.fqn, c2.fqn
----
// end::designsmellSibling[]


=== Hierarchy

==== Monarch
// tag::designsmellMonarch[]
[[designsmell:Monarch]]
[source,cypher,role=concept]
.A class whose inheritance hierarchy goes very deep.
----
MATCH
  h=(m:Class)-[:EXTENDS*]->(t:Type)
RETURN
  m.fqn, length(h) as Depth
ORDER BY
  Depth desc
LIMIT 1
----
// end::designsmellMonarch[]

==== Cyclic Hierarchy
// tag::designsmellCyclicHierarchy[]
[[designsmell:CyclicHierarchy]]
[source,cypher,role=concept]
.A supertype refers to any of its subtypes.
----
MATCH
  (subtype:Type)-[:EXTENDS]->(supertype:Type)
WHERE
  (supertype)-[:DEPENDS_ON]->(subtype)
RETURN
  supertype.fqn
----
// end::designsmellCyclicHierarchy

// tag::designsmellCyclicHierarchyAdvanced[]
[[designsmell:CyclicHierarchyAdvanced]]
[source,cypher,role=concept,reportType="plantuml-class-diagram"]
.Advanced: query result produces class diagram.
----
MATCH
  (subtype:Type)-[:EXTENDS]->(supertype:Type)
WHERE
  (supertype)-[:DEPENDS_ON]->(subtype)
OPTIONAL MATCH
  (subtype)-[e:EXTENDS]->(supertype)
OPTIONAL MATCH
  (supertype)-[d:DEPENDS_ON]->(subtype)
OPTIONAL MATCH
  (supertype)-[:DECLARES]->(f:Method)
OPTIONAL MATCH
  (subtype)-[:DECLARES]->(m:Method)
RETURN
  *
----
// end::designsmellCyclicHierarchyAdvanced

=== Modularization

==== Cycler

===== Cycler (Simple Version)
// tag::designsmellCyclerSimple[]
[[designsmell:CyclerSimple]]
[source,cypher,role=concept]
.A class within a dependency cycle.
----
MATCH
  (c1)-[:DEPENDS_ON*]->(c1)
RETURN
  c1
----
// end::designsmellCyclerSimple[]

===== Cycler (Advanced Version)
// tag::designsmellCyclerAdvanced[]
[[designsmell:CyclerAdvanced]]
[source,cypher,role=concept,reportType="plantuml-class-diagram"]
.A class within a dependency cycle (advanced: query results produces class diagram).
----
MATCH
  (c1)-[:DEPENDS_ON]->(c2),
  cycle=shortestPath((c2)-[:DEPENDS_ON*]->(c1))
RETURN
  *
----
// end::designsmellCyclerAdvanced[]


=== Encapsulation

==== Glass Class

==== Instagrammer
// broken
// tag::designsmellInstagrammer[]
[[designsmell:Instagrammer]]
[source,cypher,role=concept]
.someText
----
MATCH (insta:Class {name: "Instagrammer"})-[:DECLARES]->(publicMethod:Method { visibility: "public"})
OPTIONAL MATCH
(client:Class)-[:DECLARES]->(clientMethod:Method)-[:INVOKES]->(publicMethod)
WHERE
	insta <> client AND
    NOT publicMethod:Constructor
return publicMethod.name
----
// end::designsmellInstagrammer[]


==== Whistleblower
// broken
// tag::designsmellWhistleblower[]
[[designsmell:Whistleblower]]
[source,cypher,role=concept]
.someText
----
MATCH
    depPath = (client:Class {name:"Client"})-[:DEPENDS_ON*]->(internal:Class)<-[:CONTAINS]-(p:Package { name:"impl"})
RETURN depPath
----
// end::designsmellWhistleblower[]
